{"version":3,"file":"index.cjs.js","sources":["../src/defaultConfig.js","../src/objectDeepValueUtils.js","../src/makeMutations.js","../src/makeGetters.js","../src/makeSetters.js","../src/index.js"],"sourcesContent":["\nexport default {\n  setter: 'set',\n  getter: 'get',\n  vuexEasyFirestore: false,\n  ignorePrivateProps: true,\n  ignoreProps: [],\n  pattern: 'standard'\n}\n","import { isArray } from 'is-what'\n\n/**\n * Returns the keys of a path\n *\n * @param   {string} path   a/path/like.this\n * @returns {array} with keys\n */\nfunction getKeysFromPath (path) {\n  if (!path) return []\n  return path.match(/\\w+/g)\n}\n\n/**\n * Gets a deep property in an object, based on a path to that property\n *\n * @param {object} target an object to wherefrom to retrieve the deep reference of\n * @param {string} path   'path/to.prop'\n *\n * @returns {object} the property which was requested\n */\nfunction getDeepRef (target = {}, path) {\n  let keys = getKeysFromPath(path)\n  if (!keys.length) return target\n  let obj = target\n  while (obj && keys.length > 1) {\n    obj = obj[keys.shift()]\n  }\n  let key = keys.shift()\n  if (obj && obj.hasOwnProperty(key)) {\n    return obj[key]\n  }\n}\n\n/**\n * Gets a deep property in an object, based on a path to that property\n *\n * @param   {object} target   the Object to get the value of\n * @param   {string} path     'path/to/prop.subprop'\n *\n * @returns {object}          the property's value\n */\nfunction getDeepValue (target, path) {\n  return getDeepRef(target, path)\n}\n\n/**\n * Sets a value to a deep property in an object, based on a path to that property\n *\n * @param   {object} target   the Object to set the value on\n * @param   {string} path     'path/to/prop.subprop'\n * @param   {*}      value    the value to set\n *\n * @returns {object}          the original target object\n */\nfunction setDeepValue (target, path, value) {\n  const keys = getKeysFromPath(path)\n  const lastKey = keys.pop()\n  const deepRef = getDeepRef(target, keys.join())\n  if (deepRef && deepRef.hasOwnProperty(lastKey)) {\n    deepRef[lastKey] = value\n  }\n  return target\n}\n\n/**\n * Pops a value of an array which is a deep property in an object, based on a path to that property\n *\n * @param   {object} target   the Object to set the value on\n * @param   {string} path     'path.to.sub.prop'\n *\n * @returns {*}               the popped value\n */\nfunction popDeepValue (target, path) {\n  const deepRef = getDeepRef(target, path)\n  if (!isArray(deepRef)) return\n  return deepRef.pop()\n}\n\n/**\n * Pushes a value in an array which is a deep property in an object, based on a path to that property\n *\n * @param   {object} target   the Object to set the value on\n * @param   {string} path     'path/to.sub.prop'\n * @param   {*}      value    the value to set\n *\n * @returns {number}          the new length of the array\n */\nfunction pushDeepValue (target, path, value) {\n  const deepRef = getDeepRef(target, path)\n  if (!isArray(deepRef)) return\n  return deepRef.push(value)\n}\n\n/**\n * Splice into an array which is a deep property in an object, based on a path to that property\n *\n * @param   {object} target       the Object to set the value on\n * @param   {string} path         'path/to.sub.prop'\n * @param   {*}      value        the value to splice in\n * @param   {number} index        the index to splice in the value, defaults to 0\n * @param   {number} deleteCount  the amount of items to delete, defaults to 0\n *\n * @returns {array}              an array containing the deleted elements\n */\nfunction spliceDeepValue (target, path, index = 0, deleteCount = 0, value) {\n  const deepRef = getDeepRef(target, path)\n  if (!isArray(deepRef)) return\n  return deepRef.splice(index, deleteCount, value)\n}\n\nexport { getDeepRef, getKeysFromPath, setDeepValue, getDeepValue, popDeepValue, pushDeepValue, spliceDeepValue }\n","import { setDeepValue, popDeepValue, pushDeepValue, spliceDeepValue } from './objectDeepValueUtils'\nimport { isObject, isArray } from 'is-what'\nimport defaultConf from './defaultConfig'\n\n/**\n * Creates the mutations for each property of the object passed recursively\n *\n * @param   {object} propParent an Object of which all props will get a mutation\n * @param   {string} path       the path taken until the current propParent instance\n * @param   {object} conf       user config\n *\n * @returns {object}            all mutations for each property.\n */\nfunction makeMutationsForAllProps(\n  propParent,\n  path,\n  conf = {}\n) {\n  conf = Object.assign({}, defaultConf, conf)\n  if (!isObject(propParent)) return {}\n  return Object.keys(propParent)\n  .reduce((mutations, prop) => {\n    // Get the path info up until this point\n    let propPath = (!path)\n      ? prop\n      : path + '.' + prop\n    // mutation name\n    let name = (conf.pattern === 'simple')\n      ? propPath\n      : 'SET_' + propPath.toUpperCase()\n    // Avoid making setters for private props\n    if (conf.ignorePrivateProps && prop[0] === '_') return mutations\n    if (conf.ignoreProps\n      // replace 'module/submodule/prop.subprop' with 'prop.subprop'\n      // because: moduleNS is not knowns when this is called\n      .map(p => p.replace(/(.*?)\\/([^\\/]*?)$/, '$2'))\n      .includes(propPath)\n    ) {\n      return mutations\n    }\n    // All good, make the action!\n    mutations[name] = (state, newVal) => {\n      return setDeepValue(state, propPath, newVal)\n    }\n    // BTW, check if the value of this prop was an object, if so, let's do it's children as well!\n    let propValue = propParent[prop]\n    if (isObject(propValue)) {\n      let childrenMutations = makeMutationsForAllProps(propValue, propPath, conf)\n      mutations = {...mutations, ...childrenMutations}\n    }\n    // If the prop is an array, make array mutations as well\n    if (isArray(propValue)) {\n      // mutation name\n      let pop = (conf.pattern === 'simple')\n        ? propPath + '.pop'\n        : 'POP_' + propPath.toUpperCase()\n      mutations[pop] = (state) => {\n        return popDeepValue(state, propPath)\n      }\n      // mutation name\n      let push = (conf.pattern === 'simple')\n        ? propPath + '.push'\n        : 'PUSH_' + propPath.toUpperCase()\n      mutations[push] = (state, value) => {\n        return pushDeepValue(state, propPath, value)\n      }\n      // mutation name\n      let splice = (conf.pattern === 'simple')\n        ? propPath + '.splice'\n        : 'SPLICE_' + propPath.toUpperCase()\n      mutations[splice] = (state, array) => {\n        return spliceDeepValue(state, propPath, ...array)\n      }\n    }\n    return mutations\n  }, {})\n}\n\n/**\n * Creates all mutations for the state of a module.\n * Usage:\n * commit('module/path/SET_PATH.TO.PROP', newValue)\n * Import method:\n * mutations {\n *   ...defaultMutations (initialState)\n * }\n *\n * @param   {object} initialState  the initial state of a module\n * @param   {object} conf          user config\n *\n * @returns {object}                all mutations for the state\n */\nfunction defaultMutations (initialState, conf = {}) {\n  conf = Object.assign({}, defaultConf, conf)\n  return makeMutationsForAllProps(initialState, null, conf)\n}\n\nexport { defaultMutations }\n","import { getDeepValue } from './objectDeepValueUtils'\n\n/**\n * Creates a getter function in the store to set any state value\n * Usage:\n * `get('module/path/path.to.prop')`\n * it will check first for existence of: `getters['module/path/path.to.prop']`\n * if non existant it will return: `state.module.path.path.to.prop`\n * Import method:\n * `store.get = (path) => { return defaultGetter(path, store) }`\n *\n * @param   {string}   path     the path of the prop to get eg. 'info/user/favColours.primary'\n * @param   {object}   store    the store to attach\n *\n * @returns {function}          getter or state\n */\nfunction defaultGetter (path, store) {\n  const getterExists = store.getters.hasOwnProperty(path)\n  if (getterExists) return store.getters[path]\n  return getDeepValue(store.state, path)\n}\n\nexport { defaultGetter }\n","import { getKeysFromPath, setDeepValue, getDeepRef } from './objectDeepValueUtils'\nimport { isObject } from 'is-what'\nimport defaultConf from './defaultConfig'\n\n/**\n * Creates a setter function in the store to set any state value\n * Usage:\n * `set('module/path/path.to.prop', newValue)`\n * it will check first for existence of: `dispatch('module/path/setPath.to.prop')`\n * if non existant it will execute: `commit('module/path/SET_PATH.TO.PROP', newValue)`\n * Import method:\n * `store.set = (path, payload) => { return defaultSetter(path, payload, store) }`\n *\n * @param   {string}   path     the path of the prop to set eg. 'info/user/favColours.primary'\n * @param   {*}        payload  the payload to set the prop to\n * @param   {object}   store    the store to attach\n * @param   {object}   conf     user config\n *\n * @returns {function}          dispatch or commit\n */\nfunction defaultSetter (path, payload, store, conf = {}) {\n  conf = Object.assign({}, defaultConf, conf)\n  // path = 'info/user/favColours.primary'\n  const pArr = path.split('/')\n  // ['info', 'user', 'favColours.primary']\n  const props = pArr.pop()\n  // 'favColours.primary'\n  const modulePath = (pArr.length)\n    ? pArr.join('/') + '/'\n    : ''\n  // 'info/user/'\n  const actionName = (conf.pattern === 'simple')\n    ? props\n    : 'set' + props[0].toUpperCase() + props.substring(1)\n  // 'setFavColours.primary'\n  const actionPath = modulePath + actionName\n  // 'info/user/setFavColours.primary'\n  const actionExists = store._actions[actionPath]\n  if (actionExists) {\n    return store.dispatch(actionPath, payload)\n  }\n  if (conf.vuexEasyFirestore) {\n    // 'info/user/set', {favColours: {primary: payload}}'\n    const pathIsModule = store._modulesNamespaceMap[path + '/']\n    const firestoreActionPath = (pathIsModule)\n      ? path + '/set'\n      : modulePath + 'set'\n    const newPayload = (pathIsModule)\n      ? payload\n      : {}\n    if (!pathIsModule) newPayload[props] = payload\n    const firestoreActionExists = store._actions[firestoreActionPath]\n    if (firestoreActionExists) {\n      return store.dispatch(firestoreActionPath, newPayload)\n    }\n  }\n  const mutationName = (conf.pattern === 'simple')\n    ? props\n    : 'SET_' + props.toUpperCase()\n  const mutationPath = modulePath + mutationName\n  const mutationExists = store._mutations[mutationPath]\n  if (mutationExists) {\n    return store.commit(mutationPath, payload)\n  }\n  console.error(`There is no mutation set for '${mutationPath}'.\n    Please add a mutation like so in the correct module:\n\n    mutations: {\n      '${mutationName}': ({state}, payload) => {\n        state.${props} = payload\n      }\n    }\n\n    You can also add mutations automatically with vuex-easy-access.\n    See the documentation here:\n      https://github.com/mesqueeb/VuexEasyAccess#2-automatically-generate-mutations-for-each-state-property`\n  )\n}\n\n/**\n * Creates a special 'setter-module' to be registered as a child of a module. This 'setter-module' will have the 'set' namespace (by default) and have one setter action per state prop in the parent module. The setter action's name will be the state prop name.\n *\n * @param {object} targetState   parent module's state object\n * @param {string} [moduleNS=''] parent module's namespace, must end in '/'\n * @param {object} store         vuex store\n * @param {object} conf          user config\n * @returns a special 'setter-module' to be registered as child of target module.\n */\nfunction createSetterModule (targetState, moduleNS = '', store, conf = {}) {\n  conf = Object.assign({}, defaultConf, conf)\n  function getSetters (_targetState, _propPath = '') {\n    return Object.keys(_targetState).reduce((carry, stateProp) => {\n      // Get the path info up until this point\n      const propPath = (_propPath)\n        ? _propPath + '.' + stateProp\n        : stateProp\n      const fullPath = moduleNS + propPath\n      // Avoid making setters for private props\n      if (conf.ignorePrivateProps && stateProp[0] === '_') return carry\n      if (conf.ignoreProps.includes(fullPath)) return carry\n      // Avoid making setters for props which are an entire module on its own\n      if (store._modulesNamespaceMap[fullPath + '/']) return carry\n      // All good, make the action!\n      carry[propPath] = (context, payload) => {\n        return defaultSetter(fullPath, payload, store, conf)\n      }\n      // BTW, check if the value of this prop was an object, if so, let's do it's children as well!\n      let propVal = _targetState[stateProp]\n      if (isObject(propVal) && Object.keys(propVal).length) {\n        const childrenSetters = getSetters(propVal, propPath)\n        Object.assign(carry, childrenSetters)\n      }\n      return carry\n    }, {})\n  }\n  const setters = getSetters(targetState)\n  return {actions: setters, namespaced: true}\n}\n\n// if everything's namespaced _modulesNameSpaceMap will work just fine.\n// function getModulesNameSpaceMap (_module, ns = '') {\n//   if (!_module || !_module._children) return console.log(_module)\n//   return Object.keys(_module._children).reduce((carry, key) => {\n//     const childModule = _module._children[key]\n//     const moduleNS = ns + key + '/'\n//     carry[moduleNS] = childModule\n//     const childrensModules = getModulesNameSpaceMap(childModule, moduleNS)\n//     Object.assign(carry, childrensModules)\n//     return carry\n//   }, {})\n// }\n\nfunction generateSetterModules (store, setterIdentifier, conf = {}) {\n  const modules = store._modulesNamespaceMap\n  Object.keys(modules).forEach(moduleNS => {\n    const _module = modules[moduleNS]\n    const moduleName = getKeysFromPath(moduleNS + setterIdentifier)\n    const setterModule = createSetterModule(_module.state, moduleNS, store, conf)\n    store.registerModule(moduleName, setterModule)\n  })\n  conf = Object.assign({}, defaultConf, conf)\n  const rootModuleName = setterIdentifier\n  const rootSetterModule = createSetterModule(store.state, '', store, conf)\n  store.registerModule(rootModuleName, rootSetterModule)\n}\n\nexport { defaultSetter, generateSetterModules }\n","/**\n * Vuex Easy Access plugin\n * Unified syntax with simple set() and get() store access + auto generate mutations!\n *\n * @author     Luca Ban\n * @contact    https://lucaban.com\n */\n\nimport defaultConfig from './defaultConfig'\nimport { defaultMutations } from './makeMutations'\nimport { defaultGetter } from './makeGetters'\nimport { defaultSetter, generateSetterModules } from './makeSetters'\nimport { getDeepRef, getKeysFromPath } from './objectDeepValueUtils'\n\nfunction createEasyAccess (userConfig) {\n  const conf = Object.assign({}, defaultConfig, userConfig)\n  return store => {\n    generateSetterModules(store, conf.setter, conf)\n    store[conf.setter] = (path, payload) => { return defaultSetter(path, payload, store, conf) }\n    store[conf.getter] = (path) => { return defaultGetter(path, store) }\n  }\n}\n\nexport default createEasyAccess\nexport { createEasyAccess, defaultMutations, defaultSetter, defaultGetter, getDeepRef, getKeysFromPath }\n"],"names":["getKeysFromPath","path","match","getDeepRef","target","keys","length","obj","shift","key","hasOwnProperty","getDeepValue","setDeepValue","value","lastKey","pop","deepRef","join","popDeepValue","isArray","pushDeepValue","push","spliceDeepValue","index","deleteCount","splice","makeMutationsForAllProps","propParent","conf","Object","assign","defaultConf","isObject","reduce","mutations","prop","propPath","name","pattern","toUpperCase","ignorePrivateProps","ignoreProps","map","p","replace","includes","state","newVal","propValue","childrenMutations","array","defaultMutations","initialState","defaultGetter","store","getterExists","getters","defaultSetter","payload","pArr","split","props","modulePath","actionName","substring","actionPath","actionExists","_actions","dispatch","vuexEasyFirestore","pathIsModule","_modulesNamespaceMap","firestoreActionPath","newPayload","firestoreActionExists","mutationName","mutationPath","mutationExists","_mutations","commit","error","createSetterModule","targetState","moduleNS","getSetters","_targetState","_propPath","carry","stateProp","fullPath","context","propVal","childrenSetters","setters","actions","namespaced","generateSetterModules","setterIdentifier","modules","forEach","_module","moduleName","setterModule","registerModule","rootModuleName","rootSetterModule","createEasyAccess","userConfig","defaultConfig","setter","getter"],"mappings":"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"}