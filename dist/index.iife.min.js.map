{"version":3,"file":"index.iife.min.js","sources":["../src/defaultConfig.js","../src/objectDeepValueUtils.js","../src/makeMutations.js","../src/makeGetters.js","../src/makeSetters.js","../src/index.js"],"sourcesContent":["\nexport default {\n  setter: 'set',\n  getter: 'get',\n  vuexEasyFirestore: false,\n  ignorePrivateProps: true,\n  pattern: 'standard'\n}\n","import { isArray } from 'is-what'\n\n/**\n * Returns the keys of a path\n *\n * @param   {string} path   a/path/like.this\n * @returns {array} with keys\n */\nfunction getKeysFromPath (path) {\n  if (!path) return []\n  return path.match(/\\w+/g)\n}\n\n/**\n * Gets a deep property in an object, based on a path to that property\n *\n * @param {object} target an object to wherefrom to retrieve the deep reference of\n * @param {string} path   'path/to.prop'\n *\n * @returns {object} the property which was requested\n */\nfunction getDeepRef (target = {}, path) {\n  let keys = getKeysFromPath(path)\n  if (!keys.length) return target\n  let obj = target\n  while (obj && keys.length > 1) {\n    obj = obj[keys.shift()]\n  }\n  let key = keys.shift()\n  if (obj && obj.hasOwnProperty(key)) {\n    return obj[key]\n  }\n}\n\n/**\n * Gets a deep property in an object, based on a path to that property\n *\n * @param   {object} target   the Object to get the value of\n * @param   {string} path     'path/to/prop.subprop'\n *\n * @returns {object}          the property's value\n */\nfunction getDeepValue (target, path) {\n  return getDeepRef(target, path)\n}\n\n/**\n * Sets a value to a deep property in an object, based on a path to that property\n *\n * @param   {object} target   the Object to set the value on\n * @param   {string} path     'path/to/prop.subprop'\n * @param   {*}      value    the value to set\n *\n * @returns {object}          the original target object\n */\nfunction setDeepValue (target, path, value) {\n  const keys = getKeysFromPath(path)\n  const lastKey = keys.pop()\n  const deepRef = getDeepRef(target, keys.join())\n  if (deepRef && deepRef.hasOwnProperty(lastKey)) {\n    deepRef[lastKey] = value\n  }\n  return target\n}\n\n/**\n * Pops a value of an array which is a deep property in an object, based on a path to that property\n *\n * @param   {object} target   the Object to set the value on\n * @param   {string} path     'path.to.sub.prop'\n *\n * @returns {*}               the popped value\n */\nfunction popDeepValue (target, path) {\n  const deepRef = getDeepRef(target, path)\n  if (!isArray(deepRef)) return\n  return deepRef.pop()\n}\n\n/**\n * Pushes a value in an array which is a deep property in an object, based on a path to that property\n *\n * @param   {object} target   the Object to set the value on\n * @param   {string} path     'path/to.sub.prop'\n * @param   {*}      value    the value to set\n *\n * @returns {number}          the new length of the array\n */\nfunction pushDeepValue (target, path, value) {\n  const deepRef = getDeepRef(target, path)\n  if (!isArray(deepRef)) return\n  return deepRef.push(value)\n}\n\n/**\n * Splice into an array which is a deep property in an object, based on a path to that property\n *\n * @param   {object} target       the Object to set the value on\n * @param   {string} path         'path/to.sub.prop'\n * @param   {*}      value        the value to splice in\n * @param   {number} index        the index to splice in the value, defaults to 0\n * @param   {number} deleteCount  the amount of items to delete, defaults to 0\n *\n * @returns {array}              an array containing the deleted elements\n */\nfunction spliceDeepValue (target, path, index = 0, deleteCount = 0, value) {\n  const deepRef = getDeepRef(target, path)\n  if (!isArray(deepRef)) return\n  return deepRef.splice(index, deleteCount, value)\n}\n\nexport { getDeepRef, getKeysFromPath, setDeepValue, getDeepValue, popDeepValue, pushDeepValue, spliceDeepValue }\n","import { setDeepValue, popDeepValue, pushDeepValue, spliceDeepValue } from './objectDeepValueUtils'\nimport { isObject, isArray } from 'is-what'\nimport defaultConf from './defaultConfig'\n\n/**\n * Creates the mutations for each property of the object passed recursively\n *\n * @param   {object} propParent an Object of which all props will get a mutation\n * @param   {string} path       the path taken until the current propParent instance\n * @param   {object} conf       user config\n *\n * @returns {object}            all mutations for each property.\n */\nfunction makeMutationsForAllProps(\n  propParent,\n  path,\n  conf = {}\n) {\n  conf = Object.assign({}, defaultConf, conf)\n  if (!isObject(propParent)) return {}\n  return Object.keys(propParent)\n  .reduce((mutations, prop) => {\n    if (conf.ignorePrivateProps && prop[0] === '_') return mutations\n    let propPath = (!path)\n      ? prop\n      : path + '.' + prop\n    // mutation name\n    let name = (conf.pattern === 'simple')\n      ? propPath\n      : 'SET_' + propPath.toUpperCase()\n    mutations[name] = (state, newVal) => {\n      return setDeepValue(state, propPath, newVal)\n    }\n    let propValue = propParent[prop]\n    // If the prop is an object, make the children mutations as well\n    if (isObject(propValue)) {\n      let childrenMutations = makeMutationsForAllProps(propValue, propPath, conf)\n      mutations = {...mutations, ...childrenMutations}\n    }\n    // If the prop is an array, make array mutations as well\n    if (isArray(propValue)) {\n      // mutation name\n      let pop = (conf.pattern === 'simple')\n        ? propPath + '.pop'\n        : 'POP_' + propPath.toUpperCase()\n      mutations[pop] = (state) => {\n        return popDeepValue(state, propPath)\n      }\n      // mutation name\n      let push = (conf.pattern === 'simple')\n        ? propPath + '.push'\n        : 'PUSH_' + propPath.toUpperCase()\n      mutations[push] = (state, value) => {\n        return pushDeepValue(state, propPath, value)\n      }\n      // mutation name\n      let splice = (conf.pattern === 'simple')\n        ? propPath + '.splice'\n        : 'SPLICE_' + propPath.toUpperCase()\n      mutations[splice] = (state, array) => {\n        return spliceDeepValue(state, propPath, ...array)\n      }\n    }\n    return mutations\n  }, {})\n}\n\n/**\n * Creates all mutations for the state of a module.\n * Usage:\n * commit('module/path/SET_PATH.TO.PROP', newValue)\n * Import method:\n * mutations {\n *   ...defaultMutations (initialState)\n * }\n *\n * @param   {object} initialState  the initial state of a module\n * @param   {object} conf          user config\n *\n * @returns {object}                all mutations for the state\n */\nfunction defaultMutations (initialState, conf = {}) {\n  conf = Object.assign({}, defaultConf, conf)\n  return makeMutationsForAllProps(initialState, null, conf)\n}\n\nexport { defaultMutations }\n","import { getDeepValue } from './objectDeepValueUtils'\n\n/**\n * Creates a getter function in the store to set any state value\n * Usage:\n * `get('module/path/path.to.prop')`\n * it will check first for existence of: `getters['module/path/path.to.prop']`\n * if non existant it will return: `state.module.path.path.to.prop`\n * Import method:\n * `store.get = (path) => { return defaultGetter(path, store) }`\n *\n * @param   {string}   path     the path of the prop to get eg. 'info/user/favColours.primary'\n * @param   {object}   store    the store to attach\n *\n * @returns {function}          getter or state\n */\nfunction defaultGetter (path, store) {\n  const getterExists = store.getters.hasOwnProperty(path)\n  if (getterExists) return store.getters[path]\n  return getDeepValue(store.state, path)\n}\n\nexport { defaultGetter }\n","import { getKeysFromPath, setDeepValue, getDeepRef } from './objectDeepValueUtils'\nimport { isObject } from 'is-what'\nimport defaultConf from './defaultConfig'\n\n/**\n * Creates a setter function in the store to set any state value\n * Usage:\n * `set('module/path/path.to.prop', newValue)`\n * it will check first for existence of: `dispatch('module/path/setPath.to.prop')`\n * if non existant it will execute: `commit('module/path/SET_PATH.TO.PROP', newValue)`\n * Import method:\n * `store.set = (path, payload) => { return defaultSetter(path, payload, store) }`\n *\n * @param   {string}   path     the path of the prop to set eg. 'info/user/favColours.primary'\n * @param   {*}        payload  the payload to set the prop to\n * @param   {object}   store    the store to attach\n * @param   {object}   conf     user config\n *\n * @returns {function}          dispatch or commit\n */\nfunction defaultSetter (path, payload, store, conf = {}) {\n  conf = Object.assign({}, defaultConf, conf)\n  // path = 'info/user/favColours.primary'\n  const pArr = path.split('/')\n  // ['info', 'user', 'favColours.primary']\n  const props = pArr.pop()\n  // 'favColours.primary'\n  const modulePath = (pArr.length)\n    ? pArr.join('/') + '/'\n    : ''\n  // 'info/user/'\n  const actionName = (conf.pattern === 'simple')\n    ? props\n    : 'set' + props[0].toUpperCase() + props.substring(1)\n  // 'setFavColours.primary'\n  const actionPath = modulePath + actionName\n  // 'info/user/setFavColours.primary'\n  const actionExists = store._actions[actionPath]\n  if (actionExists) {\n    return store.dispatch(actionPath, payload)\n  }\n  if (conf.vuexEasyFirestore) {\n    // 'info/user/set', {favColours: {primary: payload}}'\n    const pathIsModule = store._modulesNamespaceMap[path + '/']\n    const firestoreActionPath = (pathIsModule)\n      ? path + '/set'\n      : modulePath + 'set'\n    const newPayload = (pathIsModule)\n      ? payload\n      : {}\n    if (!pathIsModule) newPayload[props] = payload\n    const firestoreActionExists = store._actions[firestoreActionPath]\n    if (firestoreActionExists) {\n      return store.dispatch(firestoreActionPath, newPayload)\n    }\n  }\n  const mutationName = (conf.pattern === 'simple')\n    ? props\n    : 'SET_' + props.toUpperCase()\n  const mutationPath = modulePath + mutationName\n  const mutationExists = store._mutations[mutationPath]\n  if (mutationExists) {\n    return store.commit(mutationPath, payload)\n  }\n  console.error(`There is no mutation set for '${mutationPath}'.\n    Please add a mutation like so in the correct module:\n\n    mutations: {\n      '${mutationName}': ({state}, payload) => {\n        state.${props} = payload\n      }\n    }\n\n    You can also add mutations automatically with vuex-easy-access.\n    See the documentation here:\n      https://github.com/mesqueeb/VuexEasyAccess#2-automatically-generate-mutations-for-each-state-property`\n  )\n}\n\n/**\n * Creates a special 'setter-module' to be registered as a child of a module. This 'setter-module' will have the 'set' namespace (by default) and have one setter action per state prop in the parent module. The setter action's name will be the state prop name.\n *\n * @param {object} targetState   parent module's state object\n * @param {string} [moduleNS=''] parent module's namespace, must end in '/'\n * @param {object} store         vuex store\n * @param {object} conf          user config\n * @returns a special 'setter-module' to be registered as child of target module.\n */\nfunction createSetterModule (targetState, moduleNS = '', store, conf = {}) {\n  conf = Object.assign({}, defaultConf, conf)\n  function getSetters (_targetState, _propPath = '') {\n    return Object.keys(_targetState).reduce((carry, stateProp) => {\n      // Avoid making setters for private props\n      if (conf.ignorePrivateProps && stateProp[0] === '_') return carry\n      // Avoid making setters for child module props in parent\n      if (store._modulesNamespaceMap[moduleNS + stateProp + '/']) return carry\n      const propPath = (_propPath)\n        ? _propPath + '.' + stateProp\n        : stateProp\n      const fullPath = moduleNS + propPath\n      carry[propPath] = (context, payload) => {\n        return defaultSetter(fullPath, payload, store, conf)\n      }\n      let propVal = _targetState[stateProp]\n      if (isObject(propVal) && Object.keys(propVal).length) {\n        const childrenSetters = getSetters(propVal, propPath)\n        Object.assign(carry, childrenSetters)\n      }\n      return carry\n    }, {})\n  }\n  const setters = getSetters(targetState)\n  return {actions: setters, namespaced: true}\n}\n\n// if everything's namespaced _modulesNameSpaceMap will work just fine.\n// function getModulesNameSpaceMap (_module, ns = '') {\n//   if (!_module || !_module._children) return console.log(_module)\n//   return Object.keys(_module._children).reduce((carry, key) => {\n//     const childModule = _module._children[key]\n//     const moduleNS = ns + key + '/'\n//     carry[moduleNS] = childModule\n//     const childrensModules = getModulesNameSpaceMap(childModule, moduleNS)\n//     Object.assign(carry, childrensModules)\n//     return carry\n//   }, {})\n// }\n\nfunction generateSetterModules (store, setterIdentifier, conf = {}) {\n  const modules = store._modulesNamespaceMap\n  Object.keys(modules).forEach(moduleNS => {\n    const _module = modules[moduleNS]\n    const moduleName = getKeysFromPath(moduleNS + setterIdentifier)\n    const setterModule = createSetterModule(_module.state, moduleNS, store, conf)\n    store.registerModule(moduleName, setterModule)\n  })\n  conf = Object.assign({}, defaultConf, conf)\n  const rootModuleName = setterIdentifier\n  const rootSetterModule = createSetterModule(store.state, '', store, conf)\n  store.registerModule(rootModuleName, rootSetterModule)\n}\n\nexport { defaultSetter, generateSetterModules }\n","/**\n * Vuex Easy Access plugin\n * Unified syntax with simple set() and get() store access + auto generate mutations!\n *\n * @author     Luca Ban\n * @contact    https://lucaban.com\n */\n\nimport defaultConfig from './defaultConfig'\nimport { defaultMutations } from './makeMutations'\nimport { defaultGetter } from './makeGetters'\nimport { defaultSetter, generateSetterModules } from './makeSetters'\nimport { getDeepRef, getKeysFromPath } from './objectDeepValueUtils'\n\nfunction createEasyAccess (userConfig) {\n  const conf = Object.assign({}, defaultConfig, userConfig)\n  return store => {\n    generateSetterModules(store, conf.setter, conf)\n    store[conf.setter] = (path, payload) => { return defaultSetter(path, payload, store, conf) }\n    store[conf.getter] = (path) => { return defaultGetter(path, store) }\n  }\n}\n\nexport default createEasyAccess\nexport { createEasyAccess, defaultMutations, defaultSetter, defaultGetter, getDeepRef, getKeysFromPath }\n"],"names":["getKeysFromPath","path","match","getDeepRef","target","keys","length","obj","shift","key","hasOwnProperty","makeMutationsForAllProps","propParent","conf","Object","assign","defaultConf","isObject","reduce","mutations","prop","ignorePrivateProps","propPath","pattern","toUpperCase","state","newVal","value","lastKey","pop","deepRef","join","propValue","childrenMutations","isArray","popDeepValue","push","pushDeepValue","array","index","deleteCount","splice","defaultGetter","store","getters","getDeepValue","defaultSetter","payload","pArr","split","props","modulePath","actionPath","substring","_actions","dispatch","vuexEasyFirestore","pathIsModule","_modulesNamespaceMap","firestoreActionPath","newPayload","mutationName","mutationPath","_mutations","commit","error","createSetterModule","targetState","moduleNS","actions","getSetters","_targetState","_propPath","carry","stateProp","fullPath","context","propVal","childrenSetters","namespaced","createEasyAccess","userConfig","defaultConfig","setterIdentifier","modules","forEach","_module","moduleName","setterModule","registerModule","rootModuleName","rootSetterModule","setter","getter","initialState"],"mappings":"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"}