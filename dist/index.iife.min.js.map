{"version":3,"file":"index.iife.min.js","sources":["../src/defaultConfig.js","../src/objectDeepValueUtils.js","../src/makeMutations.js","../src/makeGetters.js","../src/makeSetters.js","../src/index.js"],"sourcesContent":["\nexport default {\n  setter: 'set',\n  getter: 'get',\n  vuexEasyFirestore: false,\n  ignorePrivateProps: true,\n  ignoreProps: [],\n  pattern: 'standard'\n}\n","import { isArray } from 'is-what'\n\n/**\n * Returns the keys of a path\n *\n * @param   {string} path   a/path/like.this\n * @returns {array} with keys\n */\nfunction getKeysFromPath (path) {\n  if (!path) return []\n  return path.match(/\\w+/g)\n}\n\n/**\n * Gets a deep property in an object, based on a path to that property\n *\n * @param {object} target an object to wherefrom to retrieve the deep reference of\n * @param {string} path   'path/to.prop'\n *\n * @returns {object} the property which was requested\n */\nfunction getDeepRef (target = {}, path) {\n  let keys = getKeysFromPath(path)\n  if (!keys.length) return target\n  let obj = target\n  while (obj && keys.length > 1) {\n    obj = obj[keys.shift()]\n  }\n  let key = keys.shift()\n  if (obj && obj.hasOwnProperty(key)) {\n    return obj[key]\n  }\n}\n\n/**\n * Gets a deep property in an object, based on a path to that property\n *\n * @param   {object} target   the Object to get the value of\n * @param   {string} path     'path/to/prop.subprop'\n *\n * @returns {object}          the property's value\n */\nfunction getDeepValue (target, path) {\n  return getDeepRef(target, path)\n}\n\n/**\n * Sets a value to a deep property in an object, based on a path to that property\n *\n * @param   {object} target   the Object to set the value on\n * @param   {string} path     'path/to/prop.subprop'\n * @param   {*}      value    the value to set\n *\n * @returns {object}          the original target object\n */\nfunction setDeepValue (target, path, value) {\n  const keys = getKeysFromPath(path)\n  const lastKey = keys.pop()\n  const deepRef = getDeepRef(target, keys.join())\n  if (deepRef && deepRef.hasOwnProperty(lastKey)) {\n    deepRef[lastKey] = value\n  }\n  return target\n}\n\n/**\n * Pops a value of an array which is a deep property in an object, based on a path to that property\n *\n * @param   {object} target   the Object to set the value on\n * @param   {string} path     'path.to.sub.prop'\n *\n * @returns {*}               the popped value\n */\nfunction popDeepValue (target, path) {\n  const deepRef = getDeepRef(target, path)\n  if (!isArray(deepRef)) return\n  return deepRef.pop()\n}\n\n/**\n * Pushes a value in an array which is a deep property in an object, based on a path to that property\n *\n * @param   {object} target   the Object to set the value on\n * @param   {string} path     'path/to.sub.prop'\n * @param   {*}      value    the value to set\n *\n * @returns {number}          the new length of the array\n */\nfunction pushDeepValue (target, path, value) {\n  const deepRef = getDeepRef(target, path)\n  if (!isArray(deepRef)) return\n  return deepRef.push(value)\n}\n\n/**\n * Splice into an array which is a deep property in an object, based on a path to that property\n *\n * @param   {object} target       the Object to set the value on\n * @param   {string} path         'path/to.sub.prop'\n * @param   {*}      value        the value to splice in\n * @param   {number} index        the index to splice in the value, defaults to 0\n * @param   {number} deleteCount  the amount of items to delete, defaults to 0\n *\n * @returns {array}              an array containing the deleted elements\n */\nfunction spliceDeepValue (target, path, index = 0, deleteCount = 0, value) {\n  const deepRef = getDeepRef(target, path)\n  if (!isArray(deepRef)) return\n  return deepRef.splice(index, deleteCount, value)\n}\n\nexport { getDeepRef, getKeysFromPath, setDeepValue, getDeepValue, popDeepValue, pushDeepValue, spliceDeepValue }\n","import { setDeepValue, popDeepValue, pushDeepValue, spliceDeepValue } from './objectDeepValueUtils'\nimport { isObject, isArray } from 'is-what'\nimport defaultConf from './defaultConfig'\n\n/**\n * Creates the mutations for each property of the object passed recursively\n *\n * @param   {object} propParent an Object of which all props will get a mutation\n * @param   {string} path       the path taken until the current propParent instance\n * @param   {object} conf       user config\n *\n * @returns {object}            all mutations for each property.\n */\nfunction makeMutationsForAllProps(\n  propParent,\n  path,\n  conf = {}\n) {\n  conf = Object.assign({}, defaultConf, conf)\n  if (!isObject(propParent)) return {}\n  return Object.keys(propParent)\n  .reduce((mutations, prop) => {\n    // Get the path info up until this point\n    let propPath = (!path)\n      ? prop\n      : path + '.' + prop\n    // mutation name\n    let name = (conf.pattern === 'simple')\n      ? propPath\n      : 'SET_' + propPath.toUpperCase()\n    // Avoid making setters for private props\n    if (conf.ignorePrivateProps && prop[0] === '_') return mutations\n    if (conf.ignoreProps\n      // replace 'module/submodule/prop.subprop' with 'prop.subprop'\n      // because: moduleNS is not knowns when this is called\n      .map(p => p.replace(/(.*?)\\/([^\\/]*?)$/, '$2'))\n      .includes(propPath)\n    ) {\n      return mutations\n    }\n    // All good, make the action!\n    mutations[name] = (state, newVal) => {\n      return setDeepValue(state, propPath, newVal)\n    }\n    // BTW, check if the value of this prop was an object, if so, let's do it's children as well!\n    let propValue = propParent[prop]\n    if (isObject(propValue)) {\n      let childrenMutations = makeMutationsForAllProps(propValue, propPath, conf)\n      mutations = {...mutations, ...childrenMutations}\n    }\n    // If the prop is an array, make array mutations as well\n    if (isArray(propValue)) {\n      // mutation name\n      let pop = (conf.pattern === 'simple')\n        ? propPath + '.pop'\n        : 'POP_' + propPath.toUpperCase()\n      mutations[pop] = (state) => {\n        return popDeepValue(state, propPath)\n      }\n      // mutation name\n      let push = (conf.pattern === 'simple')\n        ? propPath + '.push'\n        : 'PUSH_' + propPath.toUpperCase()\n      mutations[push] = (state, value) => {\n        return pushDeepValue(state, propPath, value)\n      }\n      // mutation name\n      let splice = (conf.pattern === 'simple')\n        ? propPath + '.splice'\n        : 'SPLICE_' + propPath.toUpperCase()\n      mutations[splice] = (state, array) => {\n        return spliceDeepValue(state, propPath, ...array)\n      }\n    }\n    return mutations\n  }, {})\n}\n\n/**\n * Creates all mutations for the state of a module.\n * Usage:\n * commit('module/path/SET_PATH.TO.PROP', newValue)\n * Import method:\n * mutations {\n *   ...defaultMutations (initialState)\n * }\n *\n * @param   {object} initialState  the initial state of a module\n * @param   {object} conf          user config\n *\n * @returns {object}                all mutations for the state\n */\nfunction defaultMutations (initialState, conf = {}) {\n  conf = Object.assign({}, defaultConf, conf)\n  return makeMutationsForAllProps(initialState, null, conf)\n}\n\nexport { defaultMutations }\n","import { getDeepValue } from './objectDeepValueUtils'\n\n/**\n * Creates a getter function in the store to set any state value\n * Usage:\n * `get('module/path/path.to.prop')`\n * it will check first for existence of: `getters['module/path/path.to.prop']`\n * if non existant it will return: `state.module.path.path.to.prop`\n * Import method:\n * `store.get = (path) => { return defaultGetter(path, store) }`\n *\n * @param   {string}   path     the path of the prop to get eg. 'info/user/favColours.primary'\n * @param   {object}   store    the store to attach\n *\n * @returns {function}          getter or state\n */\nfunction defaultGetter (path, store) {\n  const getterExists = store.getters.hasOwnProperty(path)\n  if (getterExists) return store.getters[path]\n  return getDeepValue(store.state, path)\n}\n\nexport { defaultGetter }\n","import { getKeysFromPath, setDeepValue, getDeepRef } from './objectDeepValueUtils'\nimport { isObject } from 'is-what'\nimport defaultConf from './defaultConfig'\n\n/**\n * Creates a setter function in the store to set any state value\n * Usage:\n * `set('module/path/path.to.prop', newValue)`\n * it will check first for existence of: `dispatch('module/path/setPath.to.prop')`\n * if non existant it will execute: `commit('module/path/SET_PATH.TO.PROP', newValue)`\n * Import method:\n * `store.set = (path, payload) => { return defaultSetter(path, payload, store) }`\n *\n * @param   {string}   path     the path of the prop to set eg. 'info/user/favColours.primary'\n * @param   {*}        payload  the payload to set the prop to\n * @param   {object}   store    the store to attach\n * @param   {object}   conf     user config\n *\n * @returns {function}          dispatch or commit\n */\nfunction defaultSetter (path, payload, store, conf = {}) {\n  conf = Object.assign({}, defaultConf, conf)\n  // path = 'info/user/favColours.primary'\n  const pArr = path.split('/')\n  // ['info', 'user', 'favColours.primary']\n  const props = pArr.pop()\n  // props = 'favColours.primary'\n  const modulePath = (pArr.length)\n    ? pArr.join('/') + '/'\n    : ''\n  // 'info/user/'\n  const actionName = (conf.pattern === 'simple')\n    ? props\n    : 'set' + props[0].toUpperCase() + props.substring(1)\n  // 'favColours.primary' or 'setFavColours.primary'\n  const actionPath = modulePath + actionName\n  // 'info/user/setFavColours.primary'\n  const actionExists = store._actions[actionPath]\n  if (actionExists) {\n    return store.dispatch(actionPath, payload)\n  }\n  // vuex-easy-firestore integration!\n  const pathIsModule = store._modulesNamespaceMap[path + '/']\n  // only if the full path is actually a module\n  if (conf.vuexEasyFirestore && pathIsModule) {\n    // 'info/user/set', {favColours: {primary: payload}}'\n    const firestoreActionPath = path + '/set'\n    const newPayload = payload\n    const firestoreActionExists = store._actions[firestoreActionPath]\n    if (firestoreActionExists) {\n      return store.dispatch(firestoreActionPath, newPayload)\n    }\n  }\n  const mutationName = (conf.pattern === 'simple')\n    ? props\n    : 'SET_' + props.toUpperCase()\n  // 'favColours.primary' or 'SET_FAVCOLOURS.PRIMARY'\n  const mutationPath = modulePath + mutationName\n  const mutationExists = store._mutations[mutationPath]\n  if (mutationExists) {\n    return store.commit(mutationPath, payload)\n  }\n  console.error(`There is no mutation set for '${mutationPath}'.\n    Please add a mutation like so in the correct module:\n\n    mutations: {\n      '${mutationName}': ({state}, payload) => {\n        state.${props} = payload\n      }\n    }\n\n    You can also add mutations automatically with vuex-easy-access.\n    See the documentation here:\n      https://github.com/mesqueeb/VuexEasyAccess#2-automatically-generate-mutations-for-each-state-property`\n  )\n}\n\n/**\n * Creates a special 'setter-module' to be registered as a child of a module. This 'setter-module' will have the 'set' namespace (by default) and have one setter action per state prop in the parent module. The setter action's name will be the state prop name.\n *\n * @param {object} targetState   parent module's state object\n * @param {string} [moduleNS=''] parent module's namespace, must end in '/'\n * @param {object} store         vuex store\n * @param {object} conf          user config\n * @returns a special 'setter-module' to be registered as child of target module.\n */\nfunction createSetterModule (targetState, moduleNS = '', store, conf = {}) {\n  conf = Object.assign({}, defaultConf, conf)\n  function getSetters (_targetState, _propPath = '') {\n    return Object.keys(_targetState).reduce((carry, stateProp) => {\n      // Get the path info up until this point\n      const propPath = (_propPath)\n        ? _propPath + '.' + stateProp\n        : stateProp\n      const fullPath = moduleNS + propPath\n      // Avoid making setters for private props\n      if (conf.ignorePrivateProps && stateProp[0] === '_') return carry\n      if (conf.ignoreProps.includes(fullPath)) return carry\n      // Avoid making setters for props which are an entire module on its own\n      if (store._modulesNamespaceMap[fullPath + '/']) return carry\n      // All good, make the action!\n      carry[propPath] = (context, payload) => {\n        return defaultSetter(fullPath, payload, store, conf)\n      }\n      // BTW, check if the value of this prop was an object, if so, let's do it's children as well!\n      let propVal = _targetState[stateProp]\n      if (isObject(propVal) && Object.keys(propVal).length) {\n        const childrenSetters = getSetters(propVal, propPath)\n        Object.assign(carry, childrenSetters)\n      }\n      return carry\n    }, {})\n  }\n  const setters = getSetters(targetState)\n  return {actions: setters, namespaced: true}\n}\n\n// if everything's namespaced _modulesNameSpaceMap will work just fine.\n// function getModulesNameSpaceMap (_module, ns = '') {\n//   if (!_module || !_module._children) return console.log(_module)\n//   return Object.keys(_module._children).reduce((carry, key) => {\n//     const childModule = _module._children[key]\n//     const moduleNS = ns + key + '/'\n//     carry[moduleNS] = childModule\n//     const childrensModules = getModulesNameSpaceMap(childModule, moduleNS)\n//     Object.assign(carry, childrensModules)\n//     return carry\n//   }, {})\n// }\n\nfunction generateSetterModules (store, setterIdentifier, conf = {}) {\n  const modules = store._modulesNamespaceMap\n  Object.keys(modules).forEach(moduleNS => {\n    const _module = modules[moduleNS]\n    const moduleName = getKeysFromPath(moduleNS + setterIdentifier)\n    const setterModule = createSetterModule(_module.state, moduleNS, store, conf)\n    store.registerModule(moduleName, setterModule)\n  })\n  conf = Object.assign({}, defaultConf, conf)\n  const rootModuleName = setterIdentifier\n  const rootSetterModule = createSetterModule(store.state, '', store, conf)\n  store.registerModule(rootModuleName, rootSetterModule)\n}\n\nexport { defaultSetter, generateSetterModules }\n","/**\n * Vuex Easy Access plugin\n * Unified syntax with simple set() and get() store access + auto generate mutations!\n *\n * @author     Luca Ban\n * @contact    https://lucaban.com\n */\n\nimport defaultConfig from './defaultConfig'\nimport { defaultMutations } from './makeMutations'\nimport { defaultGetter } from './makeGetters'\nimport { defaultSetter, generateSetterModules } from './makeSetters'\nimport { getDeepRef, getKeysFromPath } from './objectDeepValueUtils'\n\nfunction createEasyAccess (userConfig) {\n  const conf = Object.assign({}, defaultConfig, userConfig)\n  return store => {\n    generateSetterModules(store, conf.setter, conf)\n    store[conf.setter] = (path, payload) => { return defaultSetter(path, payload, store, conf) }\n    store[conf.getter] = (path) => { return defaultGetter(path, store) }\n  }\n}\n\nexport default createEasyAccess\nexport { createEasyAccess, defaultMutations, defaultSetter, defaultGetter, getDeepRef, getKeysFromPath }\n"],"names":["getKeysFromPath","path","match","getDeepRef","target","keys","length","obj","shift","key","hasOwnProperty","makeMutationsForAllProps","propParent","conf","Object","assign","defaultConf","isObject","reduce","mutations","prop","propPath","name","pattern","toUpperCase","ignorePrivateProps","ignoreProps","map","p","replace","includes","state","newVal","value","lastKey","pop","deepRef","join","propValue","childrenMutations","isArray","popDeepValue","push","pushDeepValue","array","index","deleteCount","splice","defaultGetter","store","getters","getDeepValue","defaultSetter","payload","pArr","split","props","modulePath","actionPath","substring","_actions","dispatch","pathIsModule","_modulesNamespaceMap","vuexEasyFirestore","firestoreActionPath","newPayload","mutationName","mutationPath","_mutations","commit","error","createSetterModule","targetState","moduleNS","actions","getSetters","_targetState","_propPath","carry","stateProp","fullPath","context","propVal","childrenSetters","namespaced","createEasyAccess","userConfig","defaultConfig","setterIdentifier","modules","forEach","_module","moduleName","setterModule","registerModule","rootModuleName","rootSetterModule","setter","getter","initialState"],"mappings":"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"}