{"version":3,"file":"index.umd.js","sources":["../src/defaultConfig.js","../src/objectDeepValueUtils.js","../src/makeMutations.js","../src/makeGetters.js","../src/makeSetters.js","../src/index.js"],"sourcesContent":["\nexport default {\n  setter: 'set',\n  getter: 'get',\n  vuexEasyFirestore: false,\n  ignorePrivateProps: true,\n  ignoreProps: [],\n  pattern: 'standard'\n}\n","import { isArray } from 'is-what'\n\n/**\n * Returns the keys of a path\n *\n * @param   {string} path   a/path/like.this\n * @returns {array} with keys\n */\nfunction getKeysFromPath (path) {\n  if (!path) return []\n  return path.match(/\\w+/g)\n}\n\n/**\n * Gets a deep property in an object, based on a path to that property\n *\n * @param {object} target an object to wherefrom to retrieve the deep reference of\n * @param {string} path   'path/to.prop'\n *\n * @returns {object} the property which was requested\n */\nfunction getDeepRef (target = {}, path) {\n  let keys = getKeysFromPath(path)\n  if (!keys.length) return target\n  let obj = target\n  while (obj && keys.length > 1) {\n    obj = obj[keys.shift()]\n  }\n  let key = keys.shift()\n  if (obj && obj.hasOwnProperty(key)) {\n    return obj[key]\n  }\n}\n\n/**\n * Gets a deep property in an object, based on a path to that property\n *\n * @param   {object} target   the Object to get the value of\n * @param   {string} path     'path/to/prop.subprop'\n *\n * @returns {object}          the property's value\n */\nfunction getDeepValue (target, path) {\n  return getDeepRef(target, path)\n}\n\n/**\n * Sets a value to a deep property in an object, based on a path to that property\n *\n * @param   {object} target   the Object to set the value on\n * @param   {string} path     'path/to/prop.subprop'\n * @param   {*}      value    the value to set\n *\n * @returns {object}          the original target object\n */\nfunction setDeepValue (target, path, value) {\n  const keys = getKeysFromPath(path)\n  const lastKey = keys.pop()\n  const deepRef = getDeepRef(target, keys.join())\n  if (deepRef && deepRef.hasOwnProperty(lastKey)) {\n    deepRef[lastKey] = value\n  }\n  return target\n}\n\n/**\n * Pops a value of an array which is a deep property in an object, based on a path to that property\n *\n * @param   {object} target   the Object to set the value on\n * @param   {string} path     'path.to.sub.prop'\n *\n * @returns {*}               the popped value\n */\nfunction popDeepValue (target, path) {\n  const deepRef = getDeepRef(target, path)\n  if (!isArray(deepRef)) return\n  return deepRef.pop()\n}\n\n/**\n * Pushes a value in an array which is a deep property in an object, based on a path to that property\n *\n * @param   {object} target   the Object to set the value on\n * @param   {string} path     'path/to.sub.prop'\n * @param   {*}      value    the value to set\n *\n * @returns {number}          the new length of the array\n */\nfunction pushDeepValue (target, path, value) {\n  const deepRef = getDeepRef(target, path)\n  if (!isArray(deepRef)) return\n  return deepRef.push(value)\n}\n\n/**\n * Splice into an array which is a deep property in an object, based on a path to that property\n *\n * @param   {object} target       the Object to set the value on\n * @param   {string} path         'path/to.sub.prop'\n * @param   {*}      value        the value to splice in\n * @param   {number} index        the index to splice in the value, defaults to 0\n * @param   {number} deleteCount  the amount of items to delete, defaults to 0\n *\n * @returns {array}              an array containing the deleted elements\n */\nfunction spliceDeepValue (target, path, index = 0, deleteCount = 0, value) {\n  const deepRef = getDeepRef(target, path)\n  if (!isArray(deepRef)) return\n  return deepRef.splice(index, deleteCount, value)\n}\n\nexport { getDeepRef, getKeysFromPath, setDeepValue, getDeepValue, popDeepValue, pushDeepValue, spliceDeepValue }\n","import { setDeepValue, popDeepValue, pushDeepValue, spliceDeepValue } from './objectDeepValueUtils'\nimport { isObject, isArray } from 'is-what'\nimport defaultConf from './defaultConfig'\n\n/**\n * Creates the mutations for each property of the object passed recursively\n *\n * @param   {object} propParent an Object of which all props will get a mutation\n * @param   {string} path       the path taken until the current propParent instance\n * @param   {object} conf       user config\n *\n * @returns {object}            all mutations for each property.\n */\nfunction makeMutationsForAllProps(\n  propParent,\n  path,\n  conf = {}\n) {\n  conf = Object.assign({}, defaultConf, conf)\n  if (!isObject(propParent)) return {}\n  return Object.keys(propParent)\n  .reduce((mutations, prop) => {\n    // Get the path info up until this point\n    let propPath = (!path)\n      ? prop\n      : path + '.' + prop\n    // mutation name\n    let name = (conf.pattern === 'simple')\n      ? propPath\n      : 'SET_' + propPath.toUpperCase()\n    // Avoid making setters for private props\n    if (conf.ignorePrivateProps && prop[0] === '_') return mutations\n    if (conf.ignoreProps\n      // replace 'module/submodule/prop.subprop' with 'prop.subprop'\n      // because: moduleNS is not knowns when this is called\n      .map(p => p.replace(/(.*?)\\/([^\\/]*?)$/, '$2'))\n      .includes(propPath)\n    ) {\n      return mutations\n    }\n    // All good, make the action!\n    mutations[name] = (state, newVal) => {\n      return setDeepValue(state, propPath, newVal)\n    }\n    // BTW, check if the value of this prop was an object, if so, let's do it's children as well!\n    let propValue = propParent[prop]\n    if (isObject(propValue)) {\n      let childrenMutations = makeMutationsForAllProps(propValue, propPath, conf)\n      mutations = {...mutations, ...childrenMutations}\n    }\n    // If the prop is an array, make array mutations as well\n    if (isArray(propValue)) {\n      // mutation name\n      let pop = (conf.pattern === 'simple')\n        ? propPath + '.pop'\n        : 'POP_' + propPath.toUpperCase()\n      mutations[pop] = (state) => {\n        return popDeepValue(state, propPath)\n      }\n      // mutation name\n      let push = (conf.pattern === 'simple')\n        ? propPath + '.push'\n        : 'PUSH_' + propPath.toUpperCase()\n      mutations[push] = (state, value) => {\n        return pushDeepValue(state, propPath, value)\n      }\n      // mutation name\n      let splice = (conf.pattern === 'simple')\n        ? propPath + '.splice'\n        : 'SPLICE_' + propPath.toUpperCase()\n      mutations[splice] = (state, array) => {\n        return spliceDeepValue(state, propPath, ...array)\n      }\n    }\n    return mutations\n  }, {})\n}\n\n/**\n * Creates all mutations for the state of a module.\n * Usage:\n * commit('module/path/SET_PATH.TO.PROP', newValue)\n * Import method:\n * mutations {\n *   ...defaultMutations (initialState)\n * }\n *\n * @param   {object} initialState  the initial state of a module\n * @param   {object} conf          user config\n *\n * @returns {object}                all mutations for the state\n */\nfunction defaultMutations (initialState, conf = {}) {\n  conf = Object.assign({}, defaultConf, conf)\n  return makeMutationsForAllProps(initialState, null, conf)\n}\n\nexport { defaultMutations }\n","import { getDeepValue } from './objectDeepValueUtils'\n\n/**\n * Creates a getter function in the store to set any state value\n * Usage:\n * `get('module/path/path.to.prop')`\n * it will check first for existence of: `getters['module/path/path.to.prop']`\n * if non existant it will return: `state.module.path.path.to.prop`\n * Import method:\n * `store.get = (path) => { return defaultGetter(path, store) }`\n *\n * @param   {string}   path     the path of the prop to get eg. 'info/user/favColours.primary'\n * @param   {object}   store    the store to attach\n *\n * @returns {function}          getter or state\n */\nfunction defaultGetter (path, store) {\n  const getterExists = store.getters.hasOwnProperty(path)\n  if (getterExists) return store.getters[path]\n  return getDeepValue(store.state, path)\n}\n\nexport { defaultGetter }\n","import { getKeysFromPath, setDeepValue, getDeepRef } from './objectDeepValueUtils'\nimport { isObject } from 'is-what'\nimport defaultConf from './defaultConfig'\n\n/**\n * Creates a setter function in the store to set any state value\n * Usage:\n * `set('module/path/path.to.prop', newValue)`\n * it will check first for existence of: `dispatch('module/path/setPath.to.prop')`\n * if non existant it will execute: `commit('module/path/SET_PATH.TO.PROP', newValue)`\n * Import method:\n * `store.set = (path, payload) => { return defaultSetter(path, payload, store) }`\n *\n * @param   {string}   path     the path of the prop to set eg. 'info/user/favColours.primary'\n * @param   {*}        payload  the payload to set the prop to\n * @param   {object}   store    the store to attach\n * @param   {object}   conf     user config\n *\n * @returns {function}          dispatch or commit\n */\nfunction defaultSetter (path, payload, store, conf = {}) {\n  conf = Object.assign({}, defaultConf, conf)\n  // path = 'info/user/favColours.primary'\n  const pArr = path.split('/')\n  // ['info', 'user', 'favColours.primary']\n  const props = pArr.pop()\n  // props = 'favColours.primary'\n  const modulePath = (pArr.length)\n    ? pArr.join('/') + '/'\n    : ''\n  // 'info/user/'\n  const actionName = (conf.pattern === 'simple')\n    ? props\n    : 'set' + props[0].toUpperCase() + props.substring(1)\n  // 'favColours.primary' or 'setFavColours.primary'\n  const actionPath = modulePath + actionName\n  // 'info/user/setFavColours.primary'\n  const actionExists = store._actions[actionPath]\n  if (actionExists) {\n    return store.dispatch(actionPath, payload)\n  }\n  // vuex-easy-firestore integration!\n  const pathIsModule = store._modulesNamespaceMap[path + '/']\n  // only if the full path is actually a module\n  if (conf.vuexEasyFirestore && pathIsModule) {\n    // 'info/user/set', {favColours: {primary: payload}}'\n    const firestoreActionPath = path + '/set'\n    const newPayload = payload\n    const firestoreActionExists = store._actions[firestoreActionPath]\n    if (firestoreActionExists) {\n      return store.dispatch(firestoreActionPath, newPayload)\n    }\n  }\n  const mutationName = (conf.pattern === 'simple')\n    ? props\n    : 'SET_' + props.toUpperCase()\n  // 'favColours.primary' or 'SET_FAVCOLOURS.PRIMARY'\n  const mutationPath = modulePath + mutationName\n  const mutationExists = store._mutations[mutationPath]\n  if (mutationExists) {\n    return store.commit(mutationPath, payload)\n  }\n  console.error(`There is no mutation set for '${mutationPath}'.\n    Please add a mutation like so in the correct module:\n\n    mutations: {\n      '${mutationName}': ({state}, payload) => {\n        state.${props} = payload\n      }\n    }\n\n    You can also add mutations automatically with vuex-easy-access.\n    See the documentation here:\n      https://github.com/mesqueeb/VuexEasyAccess#2-automatically-generate-mutations-for-each-state-property`\n  )\n}\n\n/**\n * Creates a special 'setter-module' to be registered as a child of a module. This 'setter-module' will have the 'set' namespace (by default) and have one setter action per state prop in the parent module. The setter action's name will be the state prop name.\n *\n * @param {object} targetState   parent module's state object\n * @param {string} [moduleNS=''] parent module's namespace, must end in '/'\n * @param {object} store         vuex store\n * @param {object} conf          user config\n * @returns a special 'setter-module' to be registered as child of target module.\n */\nfunction createSetterModule (targetState, moduleNS = '', store, conf = {}) {\n  conf = Object.assign({}, defaultConf, conf)\n  function getSetters (_targetState, _propPath = '') {\n    return Object.keys(_targetState).reduce((carry, stateProp) => {\n      // Get the path info up until this point\n      const propPath = (_propPath)\n        ? _propPath + '.' + stateProp\n        : stateProp\n      const fullPath = moduleNS + propPath\n      // Avoid making setters for private props\n      if (conf.ignorePrivateProps && stateProp[0] === '_') return carry\n      if (conf.ignoreProps.includes(fullPath)) return carry\n      // Avoid making setters for props which are an entire module on its own\n      if (store._modulesNamespaceMap[fullPath + '/']) return carry\n      // All good, make the action!\n      carry[propPath] = (context, payload) => {\n        return defaultSetter(fullPath, payload, store, conf)\n      }\n      // BTW, check if the value of this prop was an object, if so, let's do it's children as well!\n      let propVal = _targetState[stateProp]\n      if (isObject(propVal) && Object.keys(propVal).length) {\n        const childrenSetters = getSetters(propVal, propPath)\n        Object.assign(carry, childrenSetters)\n      }\n      return carry\n    }, {})\n  }\n  const setters = getSetters(targetState)\n  return {actions: setters, namespaced: true}\n}\n\n// if everything's namespaced _modulesNameSpaceMap will work just fine.\n// function getModulesNameSpaceMap (_module, ns = '') {\n//   if (!_module || !_module._children) return console.log(_module)\n//   return Object.keys(_module._children).reduce((carry, key) => {\n//     const childModule = _module._children[key]\n//     const moduleNS = ns + key + '/'\n//     carry[moduleNS] = childModule\n//     const childrensModules = getModulesNameSpaceMap(childModule, moduleNS)\n//     Object.assign(carry, childrensModules)\n//     return carry\n//   }, {})\n// }\n\nfunction generateSetterModules (store, setterIdentifier, conf = {}) {\n  const modules = store._modulesNamespaceMap\n  Object.keys(modules).forEach(moduleNS => {\n    const _module = modules[moduleNS]\n    const moduleName = getKeysFromPath(moduleNS + setterIdentifier)\n    const setterModule = createSetterModule(_module.state, moduleNS, store, conf)\n    store.registerModule(moduleName, setterModule)\n  })\n  conf = Object.assign({}, defaultConf, conf)\n  const rootModuleName = setterIdentifier\n  const rootSetterModule = createSetterModule(store.state, '', store, conf)\n  store.registerModule(rootModuleName, rootSetterModule)\n}\n\nexport { defaultSetter, generateSetterModules }\n","/**\n * Vuex Easy Access plugin\n * Unified syntax with simple set() and get() store access + auto generate mutations!\n *\n * @author     Luca Ban\n * @contact    https://lucaban.com\n */\n\nimport defaultConfig from './defaultConfig'\nimport { defaultMutations } from './makeMutations'\nimport { defaultGetter } from './makeGetters'\nimport { defaultSetter, generateSetterModules } from './makeSetters'\nimport { getDeepRef, getKeysFromPath } from './objectDeepValueUtils'\n\nfunction createEasyAccess (userConfig) {\n  const conf = Object.assign({}, defaultConfig, userConfig)\n  return store => {\n    generateSetterModules(store, conf.setter, conf)\n    store[conf.setter] = (path, payload) => { return defaultSetter(path, payload, store, conf) }\n    store[conf.getter] = (path) => { return defaultGetter(path, store) }\n  }\n}\n\nexport default createEasyAccess\nexport { createEasyAccess, defaultMutations, defaultSetter, defaultGetter, getDeepRef, getKeysFromPath }\n"],"names":["setter","getter","vuexEasyFirestore","ignorePrivateProps","ignoreProps","pattern","getKeysFromPath","path","match","getDeepRef","target","keys","length","obj","shift","key","hasOwnProperty","getDeepValue","setDeepValue","value","lastKey","pop","deepRef","join","popDeepValue","isArray","pushDeepValue","push","spliceDeepValue","index","deleteCount","splice","makeMutationsForAllProps","propParent","conf","Object","assign","defaultConf","isObject","reduce","mutations","prop","propPath","name","toUpperCase","map","p","replace","includes","state","newVal","propValue","childrenMutations","array","defaultMutations","initialState","defaultGetter","store","getterExists","getters","defaultSetter","payload","pArr","split","props","modulePath","actionName","substring","actionPath","actionExists","_actions","dispatch","pathIsModule","_modulesNamespaceMap","firestoreActionPath","newPayload","firestoreActionExists","mutationName","mutationPath","mutationExists","_mutations","commit","console","error","createSetterModule","targetState","moduleNS","getSetters","_targetState","_propPath","carry","stateProp","fullPath","context","propVal","childrenSetters","setters","actions","namespaced","generateSetterModules","setterIdentifier","modules","forEach","_module","moduleName","setterModule","registerModule","rootModuleName","rootSetterModule","createEasyAccess","userConfig","defaultConfig"],"mappings":"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"}