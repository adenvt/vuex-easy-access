{"version":3,"file":"index.es.min.js","sources":["../src/defaultConfig.js","../src/objectDeepValueUtils.js","../src/makeMutations.js","../src/makeGetters.js","../src/makeSetters.js","../src/index.js"],"sourcesContent":["\nexport default {\n  setter: 'set',\n  getter: 'get',\n  vuexEasyFirestore: false,\n  ignorePrivateProps: true,\n  ignoreProps: [],\n  pattern: 'standard'\n}\n","import { isArray } from 'is-what'\n\n/**\n * Returns the keys of a path\n *\n * @param   {string} path   a/path/like.this\n * @returns {array} with keys\n */\nfunction getKeysFromPath (path) {\n  if (!path) return []\n  return path.match(/\\w+/g)\n}\n\n/**\n * Gets a deep property in an object, based on a path to that property\n *\n * @param {object} target an object to wherefrom to retrieve the deep reference of\n * @param {string} path   'path/to.prop'\n *\n * @returns {object} the property which was requested\n */\nfunction getDeepRef (target = {}, path) {\n  let keys = getKeysFromPath(path)\n  if (!keys.length) return target\n  let obj = target\n  while (obj && keys.length > 1) {\n    obj = obj[keys.shift()]\n  }\n  let key = keys.shift()\n  if (obj && obj.hasOwnProperty(key)) {\n    return obj[key]\n  }\n}\n\n/**\n * Gets a deep property in an object, based on a path to that property\n *\n * @param   {object} target   the Object to get the value of\n * @param   {string} path     'path/to/prop.subprop'\n *\n * @returns {object}          the property's value\n */\nfunction getDeepValue (target, path) {\n  return getDeepRef(target, path)\n}\n\n/**\n * Sets a value to a deep property in an object, based on a path to that property\n *\n * @param   {object} target   the Object to set the value on\n * @param   {string} path     'path/to/prop.subprop'\n * @param   {*}      value    the value to set\n *\n * @returns {object}          the original target object\n */\nfunction setDeepValue (target, path, value) {\n  const keys = getKeysFromPath(path)\n  const lastKey = keys.pop()\n  const deepRef = getDeepRef(target, keys.join())\n  if (deepRef && deepRef.hasOwnProperty(lastKey)) {\n    deepRef[lastKey] = value\n  }\n  return target\n}\n\n/**\n * Pops a value of an array which is a deep property in an object, based on a path to that property\n *\n * @param   {object} target   the Object to set the value on\n * @param   {string} path     'path.to.sub.prop'\n *\n * @returns {*}               the popped value\n */\nfunction popDeepValue (target, path) {\n  const deepRef = getDeepRef(target, path)\n  if (!isArray(deepRef)) return\n  return deepRef.pop()\n}\n\n/**\n * Pushes a value in an array which is a deep property in an object, based on a path to that property\n *\n * @param   {object} target   the Object to set the value on\n * @param   {string} path     'path/to.sub.prop'\n * @param   {*}      value    the value to set\n *\n * @returns {number}          the new length of the array\n */\nfunction pushDeepValue (target, path, value) {\n  const deepRef = getDeepRef(target, path)\n  if (!isArray(deepRef)) return\n  return deepRef.push(value)\n}\n\n/**\n * Splice into an array which is a deep property in an object, based on a path to that property\n *\n * @param   {object} target       the Object to set the value on\n * @param   {string} path         'path/to.sub.prop'\n * @param   {*}      value        the value to splice in\n * @param   {number} index        the index to splice in the value, defaults to 0\n * @param   {number} deleteCount  the amount of items to delete, defaults to 0\n *\n * @returns {array}              an array containing the deleted elements\n */\nfunction spliceDeepValue (target, path, index = 0, deleteCount = 0, value) {\n  const deepRef = getDeepRef(target, path)\n  if (!isArray(deepRef)) return\n  return deepRef.splice(index, deleteCount, value)\n}\n\nexport { getDeepRef, getKeysFromPath, setDeepValue, getDeepValue, popDeepValue, pushDeepValue, spliceDeepValue }\n","import { setDeepValue, popDeepValue, pushDeepValue, spliceDeepValue } from './objectDeepValueUtils'\nimport { isObject, isArray } from 'is-what'\nimport defaultConf from './defaultConfig'\n\n/**\n * Creates the mutations for each property of the object passed recursively\n *\n * @param   {object} propParent an Object of which all props will get a mutation\n * @param   {string} path       the path taken until the current propParent instance\n * @param   {object} conf       user config\n *\n * @returns {object}            all mutations for each property.\n */\nfunction makeMutationsForAllProps(\n  propParent,\n  path,\n  conf = {}\n) {\n  conf = Object.assign({}, defaultConf, conf)\n  if (!isObject(propParent)) return {}\n  return Object.keys(propParent)\n  .reduce((mutations, prop) => {\n    // Get the path info up until this point\n    let propPath = (!path)\n      ? prop\n      : path + '.' + prop\n    // mutation name\n    let name = (conf.pattern === 'simple')\n      ? propPath\n      : 'SET_' + propPath.toUpperCase()\n    // Avoid making setters for private props\n    if (conf.ignorePrivateProps && prop[0] === '_') return mutations\n    if (conf.ignoreProps\n      // replace 'module/submodule/prop.subprop' with 'prop.subprop'\n      // because: moduleNS is not knowns when this is called\n      .map(p => p.replace(/(.*?)\\/([^\\/]*?)$/, '$2'))\n      .includes(propPath)\n    ) {\n      return mutations\n    }\n    // All good, make the action!\n    mutations[name] = (state, newVal) => {\n      return setDeepValue(state, propPath, newVal)\n    }\n    // BTW, check if the value of this prop was an object, if so, let's do it's children as well!\n    let propValue = propParent[prop]\n    if (isObject(propValue)) {\n      let childrenMutations = makeMutationsForAllProps(propValue, propPath, conf)\n      mutations = {...mutations, ...childrenMutations}\n    }\n    // If the prop is an array, make array mutations as well\n    if (isArray(propValue)) {\n      // mutation name\n      let pop = (conf.pattern === 'simple')\n        ? propPath + '.pop'\n        : 'POP_' + propPath.toUpperCase()\n      mutations[pop] = (state) => {\n        return popDeepValue(state, propPath)\n      }\n      // mutation name\n      let push = (conf.pattern === 'simple')\n        ? propPath + '.push'\n        : 'PUSH_' + propPath.toUpperCase()\n      mutations[push] = (state, value) => {\n        return pushDeepValue(state, propPath, value)\n      }\n      // mutation name\n      let splice = (conf.pattern === 'simple')\n        ? propPath + '.splice'\n        : 'SPLICE_' + propPath.toUpperCase()\n      mutations[splice] = (state, array) => {\n        return spliceDeepValue(state, propPath, ...array)\n      }\n    }\n    return mutations\n  }, {})\n}\n\n/**\n * Creates all mutations for the state of a module.\n * Usage:\n * commit('module/path/SET_PATH.TO.PROP', newValue)\n * Import method:\n * mutations {\n *   ...defaultMutations (initialState)\n * }\n *\n * @param   {object} initialState  the initial state of a module\n * @param   {object} conf          user config\n *\n * @returns {object}                all mutations for the state\n */\nfunction defaultMutations (initialState, conf = {}) {\n  conf = Object.assign({}, defaultConf, conf)\n  return makeMutationsForAllProps(initialState, null, conf)\n}\n\nexport { defaultMutations }\n","import { getDeepValue } from './objectDeepValueUtils'\n\n/**\n * Creates a getter function in the store to set any state value\n * Usage:\n * `get('module/path/path.to.prop')`\n * it will check first for existence of: `getters['module/path/path.to.prop']`\n * if non existant it will return: `state.module.path.path.to.prop`\n * Import method:\n * `store.get = (path) => { return defaultGetter(path, store) }`\n *\n * @param   {string}   path     the path of the prop to get eg. 'info/user/favColours.primary'\n * @param   {object}   store    the store to attach\n *\n * @returns {function}          getter or state\n */\nfunction defaultGetter (path, store) {\n  const getterExists = store.getters.hasOwnProperty(path)\n  if (getterExists) return store.getters[path]\n  return getDeepValue(store.state, path)\n}\n\nexport { defaultGetter }\n","import { getKeysFromPath, setDeepValue, getDeepRef } from './objectDeepValueUtils'\nimport { isObject } from 'is-what'\nimport defaultConf from './defaultConfig'\n\n/**\n * Creates a setter function in the store to set any state value\n * Usage:\n * `set('module/path/path.to.prop', newValue)`\n * it will check first for existence of: `dispatch('module/path/setPath.to.prop')`\n * if non existant it will execute: `commit('module/path/SET_PATH.TO.PROP', newValue)`\n * Import method:\n * `store.set = (path, payload) => { return defaultSetter(path, payload, store) }`\n *\n * @param   {string}   path     the path of the prop to set eg. 'info/user/favColours.primary'\n * @param   {*}        payload  the payload to set the prop to\n * @param   {object}   store    the store to attach\n * @param   {object}   conf     user config\n *\n * @returns {function}          dispatch or commit\n */\nfunction defaultSetter (path, payload, store, conf = {}) {\n  conf = Object.assign({}, defaultConf, conf)\n  // path = 'info/user/favColours.primary'\n  const pArr = path.split('/')\n  // ['info', 'user', 'favColours.primary']\n  const props = pArr.pop()\n  // 'favColours.primary'\n  const modulePath = (pArr.length)\n    ? pArr.join('/') + '/'\n    : ''\n  // 'info/user/'\n  const actionName = (conf.pattern === 'simple')\n    ? props\n    : 'set' + props[0].toUpperCase() + props.substring(1)\n  // 'setFavColours.primary'\n  const actionPath = modulePath + actionName\n  // 'info/user/setFavColours.primary'\n  const actionExists = store._actions[actionPath]\n  if (actionExists) {\n    return store.dispatch(actionPath, payload)\n  }\n  if (conf.vuexEasyFirestore) {\n    // 'info/user/set', {favColours: {primary: payload}}'\n    const pathIsModule = store._modulesNamespaceMap[path + '/']\n    const firestoreActionPath = (pathIsModule)\n      ? path + '/set'\n      : modulePath + 'set'\n    const newPayload = (pathIsModule)\n      ? payload\n      : {}\n    if (!pathIsModule) newPayload[props] = payload\n    const firestoreActionExists = store._actions[firestoreActionPath]\n    if (firestoreActionExists) {\n      return store.dispatch(firestoreActionPath, newPayload)\n    }\n  }\n  const mutationName = (conf.pattern === 'simple')\n    ? props\n    : 'SET_' + props.toUpperCase()\n  const mutationPath = modulePath + mutationName\n  const mutationExists = store._mutations[mutationPath]\n  if (mutationExists) {\n    return store.commit(mutationPath, payload)\n  }\n  console.error(`There is no mutation set for '${mutationPath}'.\n    Please add a mutation like so in the correct module:\n\n    mutations: {\n      '${mutationName}': ({state}, payload) => {\n        state.${props} = payload\n      }\n    }\n\n    You can also add mutations automatically with vuex-easy-access.\n    See the documentation here:\n      https://github.com/mesqueeb/VuexEasyAccess#2-automatically-generate-mutations-for-each-state-property`\n  )\n}\n\n/**\n * Creates a special 'setter-module' to be registered as a child of a module. This 'setter-module' will have the 'set' namespace (by default) and have one setter action per state prop in the parent module. The setter action's name will be the state prop name.\n *\n * @param {object} targetState   parent module's state object\n * @param {string} [moduleNS=''] parent module's namespace, must end in '/'\n * @param {object} store         vuex store\n * @param {object} conf          user config\n * @returns a special 'setter-module' to be registered as child of target module.\n */\nfunction createSetterModule (targetState, moduleNS = '', store, conf = {}) {\n  conf = Object.assign({}, defaultConf, conf)\n  function getSetters (_targetState, _propPath = '') {\n    return Object.keys(_targetState).reduce((carry, stateProp) => {\n      // Get the path info up until this point\n      const propPath = (_propPath)\n        ? _propPath + '.' + stateProp\n        : stateProp\n      const fullPath = moduleNS + propPath\n      // Avoid making setters for private props\n      if (conf.ignorePrivateProps && stateProp[0] === '_') return carry\n      if (conf.ignoreProps.includes(fullPath)) return carry\n      // Avoid making setters for props which are an entire module on its own\n      if (store._modulesNamespaceMap[fullPath + '/']) return carry\n      // All good, make the action!\n      carry[propPath] = (context, payload) => {\n        return defaultSetter(fullPath, payload, store, conf)\n      }\n      // BTW, check if the value of this prop was an object, if so, let's do it's children as well!\n      let propVal = _targetState[stateProp]\n      if (isObject(propVal) && Object.keys(propVal).length) {\n        const childrenSetters = getSetters(propVal, propPath)\n        Object.assign(carry, childrenSetters)\n      }\n      return carry\n    }, {})\n  }\n  const setters = getSetters(targetState)\n  return {actions: setters, namespaced: true}\n}\n\n// if everything's namespaced _modulesNameSpaceMap will work just fine.\n// function getModulesNameSpaceMap (_module, ns = '') {\n//   if (!_module || !_module._children) return console.log(_module)\n//   return Object.keys(_module._children).reduce((carry, key) => {\n//     const childModule = _module._children[key]\n//     const moduleNS = ns + key + '/'\n//     carry[moduleNS] = childModule\n//     const childrensModules = getModulesNameSpaceMap(childModule, moduleNS)\n//     Object.assign(carry, childrensModules)\n//     return carry\n//   }, {})\n// }\n\nfunction generateSetterModules (store, setterIdentifier, conf = {}) {\n  const modules = store._modulesNamespaceMap\n  Object.keys(modules).forEach(moduleNS => {\n    const _module = modules[moduleNS]\n    const moduleName = getKeysFromPath(moduleNS + setterIdentifier)\n    const setterModule = createSetterModule(_module.state, moduleNS, store, conf)\n    store.registerModule(moduleName, setterModule)\n  })\n  conf = Object.assign({}, defaultConf, conf)\n  const rootModuleName = setterIdentifier\n  const rootSetterModule = createSetterModule(store.state, '', store, conf)\n  store.registerModule(rootModuleName, rootSetterModule)\n}\n\nexport { defaultSetter, generateSetterModules }\n","/**\n * Vuex Easy Access plugin\n * Unified syntax with simple set() and get() store access + auto generate mutations!\n *\n * @author     Luca Ban\n * @contact    https://lucaban.com\n */\n\nimport defaultConfig from './defaultConfig'\nimport { defaultMutations } from './makeMutations'\nimport { defaultGetter } from './makeGetters'\nimport { defaultSetter, generateSetterModules } from './makeSetters'\nimport { getDeepRef, getKeysFromPath } from './objectDeepValueUtils'\n\nfunction createEasyAccess (userConfig) {\n  const conf = Object.assign({}, defaultConfig, userConfig)\n  return store => {\n    generateSetterModules(store, conf.setter, conf)\n    store[conf.setter] = (path, payload) => { return defaultSetter(path, payload, store, conf) }\n    store[conf.getter] = (path) => { return defaultGetter(path, store) }\n  }\n}\n\nexport default createEasyAccess\nexport { createEasyAccess, defaultMutations, defaultSetter, defaultGetter, getDeepRef, getKeysFromPath }\n"],"names":["getKeysFromPath","path","match","getDeepRef","target","keys","length","obj","shift","key","hasOwnProperty","getDeepValue","setDeepValue","value","lastKey","pop","deepRef","join","popDeepValue","isArray","pushDeepValue","push","spliceDeepValue","index","deleteCount","splice","makeMutationsForAllProps","propParent","conf","Object","assign","defaultConf","isObject","reduce","mutations","prop","propPath","name","pattern","toUpperCase","ignorePrivateProps","ignoreProps","map","p","replace","includes","state","newVal","propValue","childrenMutations","array","defaultMutations","initialState","defaultGetter","store","getters","defaultSetter","payload","pArr","split","props","modulePath","actionPath","substring","_actions","dispatch","vuexEasyFirestore","pathIsModule","_modulesNamespaceMap","firestoreActionPath","newPayload","mutationName","mutationPath","_mutations","commit","error","createSetterModule","targetState","moduleNS","actions","getSetters","_targetState","_propPath","carry","stateProp","fullPath","context","propVal","childrenSetters","namespaced","generateSetterModules","setterIdentifier","modules","forEach","_module","moduleName","setterModule","registerModule","rootModuleName","rootSetterModule","createEasyAccess","userConfig","defaultConfig","setter","getter"],"mappings":"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"}